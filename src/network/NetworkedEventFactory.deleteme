import Serializable from '../serialize/Serializable.js';
import Utils from '../lib/Utils.js';
import Serializer from '../serialize/Serializer.js';
import { netScheme } from '../serialize/NetScheme';

// TODO: this class is hacky no longer used - just a workaround to avoid creating the 4 network-event-classes as separate classes.  
//       maybe it was simpler to just create each one explicitly
export default class NetworkedEventFactory {

    private serializer: Serializer;
    private eventName: string;
    public netScheme: netScheme;
    
    constructor(serializer: Serializer, eventName: string, options) {
        options = Object.assign({}, options); 

        // this.serializer = serializer; // TODO: is this used?
        // this.options = options; // TODO: is this used?

        this.eventName = eventName;
        this.netScheme = options.netScheme;
    }

    /**
     * Creates a new networkedEvent
     * @param {Object} payload an object representing the payload to be transferred over the wire
     * @return {Serializable} the new networkedEvent object
     */
    create(payload) {
        let networkedEvent = new Serializable();
        networkedEvent.classId = Utils.hashStr(this.eventName);

        if (this.netScheme) {
            networkedEvent.netScheme = Object.assign({}, this.netScheme);

            // copy properties from the networkedEvent instance to its ad-hoc netsScheme
            for (let property of Object.keys(this.netScheme)) {
                networkedEvent[property] = payload[property];
            }

        } else {
            // todo take care of the event where no netScheme is defined
        }

        return networkedEvent;
    }

}
